import * as THREE from 'three';

export const generateGCode = (group: THREE.Group, layerHeight: number = 0.2) => {
    let gcode = [
        "; G-Code generated by Linolium3D",
        "G21 ; set units to millimeters",
        "G90 ; use absolute coordinates",
        "M82 ; use absolute distances for extrusion",
        "G28 ; home all axes",
        "G1 Z5 F5000 ; lift nozzle",
        ""
    ];

    // Simple 2.5D slicing logic
    // We'll iterate through layers and generate perimeters for each mesh in the group
    const box = new THREE.Box3().setFromObject(group);
    const minZ = box.min.z;
    const maxZ = box.max.z;

    let currentE = 0;
    const feedRate = 1200; // mm/min

    for (let z = minZ + layerHeight; z <= maxZ; z += layerHeight) {
        gcode.push(`; LAYER: ${((z - minZ) / layerHeight).toFixed(0)}`);
        gcode.push(`G1 Z${z.toFixed(3)} F5000`);

        group.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                const geometry = child.geometry;
                if (geometry instanceof THREE.ExtrudeGeometry || geometry instanceof THREE.BoxGeometry) {
                    // For simplicity in this MVP, we'll use the bounding box of each mesh to create a perimeter
                    // A real slicer would do ray-casting or cross-sectioning
                    const meshBox = new THREE.Box3().setFromObject(child);

                    // Only print if this mesh exists at this Z height
                    if (z >= meshBox.min.z && z <= meshBox.max.z) {
                        const x1 = meshBox.min.x;
                        const y1 = meshBox.min.y;
                        const x2 = meshBox.max.x;
                        const y2 = meshBox.max.y;

                        // Move to start
                        gcode.push(`G0 X${x1.toFixed(3)} Y${y1.toFixed(3)}`);

                        // Draw rectangle
                        const extrusionMultiplier = 0.05; // Simplified extrusion math

                        currentE += (x2 - x1) * extrusionMultiplier;
                        gcode.push(`G1 X${x2.toFixed(3)} Y${y1.toFixed(3)} E${currentE.toFixed(5)} F${feedRate}`);

                        currentE += (y2 - y1) * extrusionMultiplier;
                        gcode.push(`G1 X${x2.toFixed(3)} Y${y2.toFixed(3)} E${currentE.toFixed(5)}`);

                        currentE += (x2 - x1) * extrusionMultiplier;
                        gcode.push(`G1 X${x1.toFixed(3)} Y${y2.toFixed(3)} E${currentE.toFixed(5)}`);

                        currentE += (y2 - y1) * extrusionMultiplier;
                        gcode.push(`G1 X${x1.toFixed(3)} Y${y1.toFixed(3)} E${currentE.toFixed(5)}`);
                    }
                }
            }
        });
        gcode.push("");
    }

    gcode.push("M104 S0 ; turn off temperature");
    gcode.push("M140 S0 ; turn off heatbed");
    gcode.push("G28 X0 ; home X axis");
    gcode.push("M84 ; disable motors");

    return gcode.join("\n");
};
